syntax = "proto3";

package imbalancer.control.v1;

// Application-agnostic control-plane messages, unary (Go-style).
// Nodes periodically call NotifyState on the coordinator to report metrics and
// their current mode. The coordinator may push mode changes (and bounce target)
// via SetMode to each node (node exposes SetMode).

// State a node reports to the coordinator.
message NotifyStateRequest {
  string node_id = 1;         // Unique node identifier.
  double cpu_util = 2;        // CPU utilization in [0,1]; optional.
  int64 queue_len = 3;        // Current queue length; optional.
  string desired_mode = 4;    // What the node wants to be (ACTIVE / IDLE / FAILOVER / ...).
  string bounce_target = 5;   // Optional: where this node currently bounces.
  double queue_delay_ms = 6;  // Optional: last observed queue delay in ms.
}

message NotifyStateResponse {
  bool ok = 1;                // Acknowledgement of receipt.
  string message = 2;         // Optional info/debug message.
}

// Command from coordinator to a node to change mode and/or bounce target.
message SetModeRequest {
  string node_id = 1;         // Target node id.
  string mode = 2;            // ACTIVE / IDLE / FAILOVER / ...
  string bounce_target = 3;   // Where to bounce overflow traffic (optional).
}

message SetModeResponse {
  bool ok = 1;
  string message = 2;
}

// Coordinator -> clients: enumerate current active nodes.
message ActiveList {
  repeated string active_nodes = 1;
}

message Empty {}

service ImbalancerControl {
  // Node -> Coordinator: report state (unary).
  rpc NotifyState(NotifyStateRequest) returns (NotifyStateResponse);
  // Coordinator -> Node: command mode change (unary).
  rpc SetMode(SetModeRequest) returns (SetModeResponse);
  // Client -> Coordinator: fetch current active node list (unary).
  rpc GetActive(Empty) returns (ActiveList);
  // Client -> Coordinator: open a stream to receive active list updates.
  rpc ActiveStream(Empty) returns (stream ActiveList);
}
